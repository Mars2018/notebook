网络请求的发生-操作系统

#前言
---

由于之前用 C 写过一个简易版的 HTTP 服务器，上次面试时，看我代码时被问到了操作系统 socket 相关的一些比较底层的实现，被狠狠地虐了一次。发现自己只是知道了怎么使用，而对其原理的理解则非常模糊。

后续读了《Linux内核设计与实现》后，对操作系统和网络的交互有了更深的理解，于是借着当时几个问题来整理一下相关知识。

文章抛开网络相关的协议暂时不谈，只考虑操作系统层面上对数据的操作。

同时也提醒各位，如果不是特别精通的知识，不要写在简历上，不引人注意还好，要是比较不常见的，简直是给自己埋坑。

版权声明。

#Socket与文件
-------
// todo 深入到文件描述符一层重写
###文件
网络通信在 Linux 操作系统内都是通过 socket 进行，所以需要先理解 socket 的概念。

在万物皆文件的 Linux 里，系统将键盘、鼠标、硬盘块等外部设备在操作系统内都抽象为`文件`，操作系统通过`文件`来实现硬件的操作、缓冲区管理等事件。

如果以面向对象的思想来看的话，即存在着一个 File 接口，它有 `open,close,read,write` 方法，KeyBoard、Mouse、Disk 等实现 File 接口，操作系统统一操作 `File` 就能对 I/O 实体进行数据操作，而不去管到底是个什么样的实体，这种抽象大大简化了操作系统的实现难度，操作系统通过文件提供的内核接口也使得程序员编程更加简单。

###Socket
Socket 由一个五元组来表示，包括了 `源IP、源端口、传输协议、目的IP、目的端口`，五个信息一致标识了同一个 socket。它是一个网络连接的抽象，并不是实际存在的，对比我们生活中的网络关系：

- 网友 A 和 B 就像网络中的两台计算机；
- 两个人的朋友关系是靠 A 通讯录中有 B，B 通讯录中有 A 实现的；
- socket 类似于通讯录，是机器间通信的入口；

而在 Linux 操作系统中，socket 也被抽象成了一种文件。当创建一个网络连接时，操作系统会像打开一个本地文件一样，创建一个文件句柄，Linux 通过读写这个文件句柄来实现与对端计算机的通信。

普通的 socket 文件并不存在，它只是操作系统打开的一个文件句柄，但unix domain socket 也是一种特殊的 socket，我们使用 ls 命令查看 这种 socket 文件，发现它有别于普通文件的 `-` 和目录的 `d`，类型标识符为 `s`。

![socket identifier](https://ws4.sinaimg.cn/large/006tNc79ly1fqkduowwsvj30j0024a9x.jpg)

#操作系统操作Socket
---
由上，来重新理解一下系统的socket接口：

###方法
`socket()` 函数就像文件的 open 函数打开一个文件一样，socket函数也会创建一个新的文件描述符，用以方便程序对socket的操作。此时，如同打开文件时要指定打开方式是 只读、只写、附加写等一样，还需要指定要传输的网络协议，以填充socket五元组中的协议信息。

`bind()` 将文件描述符与IP和端口绑定，填充socket五元组中的本地IP、本地端口信息。

`listen()` 将文件的读取方式改为被动读取，有可读新连接出现后，接受通知，以随时受理客户端的连接。

`accept()` 在监听的被动sokcet上有新的连接请求出现时，创建一个新的 socket，并读取客户端的连接信息，包括IP/PORT，填充到这个新的socket的五元组中，成为一个完全可用的标准socket。

`connect()` 用于客户端，直接创建一个新的socket，填充五元组，然后发送向服务端的连接请求。

###socket是怎么被标注为可读的？
那么，服务器进程是如何得知 socket 可读的呢？
答案是网卡中断，当网卡检测到数据包到来时，会产生一个网卡中断，内核响应中断，从网卡缓冲区内读出数据放入协议栈内处理。处理后放入对应文件描述符的缓冲区中。


###读写
socket的读写方式跟本地I/O一样，都是进程发起系统调用 read/write，内核响应系统调用，进入内核态操作数据，对数据进行读写。

###协议栈
-------------
协议栈是操作系统对各种已知网络协议操作的服务，在发送时，内核将原始数据依次添加 IP头、TCP头等再发送给网卡。
而从网卡缓冲区复制出数据时，会识别当前包的网络协议，并从上到下依次解析，将解析出的TCP包信息复制到进程缓冲区。

#I/O 模型
------
###多路复用

###阻塞与非阻塞

###epoll

由于响应硬件中断的代价很高，epoll的通知机制并不一定采用中断，可能会采用轮询。

epoll为什么边缘触发为什么要非阻塞，水平触发则不必要

小结
---

阻塞和非阻塞
是进程相对于内核来说，即内核条件不满足时是挂起等待内核处理条件满足，还是立刻返回结果继续处理其他事情。进行轮询或其他操作。

epoll为什么边缘触发为什么要非阻塞，水平触发则不必要
边缘触发只会在边缘也就是socket变为可读或可写时触发一次，所以进程需要在一次将数据取完，而进程读取数据时，数据可能没有完全准备好，数据一次没有取完，就再也没有机会取了，除非socket下次变为可读或或写。
设置为非阻塞时，服务端可以调用循环去一直读取数据，直到返回EAGAIN错误，表示没有数据可读。
而设置为阻塞时，服务端必须要知道要读取的

而水平触发不会有这个问题，因为它会在数据没读完时持续返回socket可读，这样，一次读不完数据时就可以再次被触发为可读，从而将数据读完。

而水平触发

小结
---

首先，io复用函数如epoll/select等在等待事件发生的时候都是阻塞的。其次，这里指的非阻塞说的是io复用函数等待的事件，通常是网络连接上的io。最后，为什么使用io复用时，网络io要用非阻塞的？举一个最简单的例子，写的时候，如果协议栈写缓冲区只有1个字节，那么io复用函数会告诉你可写，但如果你此时要写2个字节，如果是阻塞io那么调用write就会阻塞。由于io复用都是单线程调用的，一个连接阻塞就会影响该线程上其他的连接，因此必须使用非阻塞io。ps：上面的答案只有一个是对的。其余的都是胡说八道。建议先搞懂write/read的真实含义以及什么时候会阻塞再来看看你们的答案吧。
finish answer: https://www.zhihu.com/question/23614342
https://ws4.sinaimg.cn/large/006tKfTcly1fqc88yrgh2j312g0l8wgc.jpg

其他的答案都没法自洽：都认为只触发一次就必须使用for循环来一次把数据读/写完，如果是阻塞的就会“阻塞”到最后一次循环，可是照这么说水平触发也会阻塞到最后一次被触发。
我觉得这个答案修改一下还可以用：
首先，写过程序的会知道，设置为非阻塞的是 serverSocket，所以考虑时只需要考虑为什么 serverSocket 需要是非阻塞的就好了。

这个答案中，问题在说“ I/O复用都是单线程调用的，一个连接阻塞就会影响该线程上其他的连接，因此必须使用非阻塞io。”，I/O复用是单线程的，可是如果给每个客户端 socket 启用一个新的线程来处理连接，就不会有这个问题了。并不是I/O复用是单线程的，而是 serverSocket 受理连接时同时只能被一个 master 线程处理。

边缘触发之边缘在于"触发条件是缓冲区由不可读/写变为可读/写"
如果 serverSocket 是阻塞的，对于缓冲区满或空时，一次无法完全读写的数据来说，内核会阻塞起来直到对端处理数据后，serverSocket 又可读/写，直到最终成功，但这样会影响其他连接的受理。即socket非常耿直，要一直处理完，不管自己长时间的处理会影响到其他人。
如果 serverSocket 是非阻塞的，如果一次无法完全读写完数据，内核会返回 EAGAIN 错误，这时，可以受理其他连接。等到对端再发送或接收数据，缓冲区由不可读写变为可读写，边缘模式还会再次触发。非阻塞时，socket会理性一些，在自己条件不满足时空出时间给别人执行，等自己条件满足了再触发执行。

在一次发送大量数据（超过发送缓冲区大小）的情况下，如果使用阻塞方式，程序一直阻塞，直到所有的数据都写入到缓冲区中。例如，要发送M字节数据，套接字发送缓冲区大小为B字节，只有当对端向本机返回ack表明其接收到大于等于M-B字节时，才意味着所有的数据都写入到缓冲区中。很明显，如果一次发送的数据量非常大，比如M=10GB、B=64KB，则：1）一次发送过程中本机线程会在一个fd上阻塞相当长一段时间，其他fd得不到及时处理；2）如果出现发送失败，无从得知到底有多少数据发送成功，应用程序只能选择重新发送这10G数据，结合考虑网络的稳定性，只能呵呵；

使用LT，可以只读一次期望大小的值，读到EAGAIN或读到期望值返回，还会再触发。
使用ET，必须使用FOR循环读，但是可能内核没准备好会阻塞住描述符上其他的数据。