服务器是如何受理一个Http请求的

操作系统受理一个网络请求
-------------
从协议栈到内核再到用户层

socket本质
--------
文件的一种，实现了文件接口的 open,close,read 和 write方法
读写handler
包含信息五元组
从创建到绑定到读写

I/O 模型
------

epoll
---
只讲 select 和 epoll， 用之前的 tinyServer 案例来说。

socket是怎么被标注为可读的？
通过网卡中断，当网卡检测到数据包到来时，会产生一个网卡中断，内核响应中断，从网卡缓冲区内读出数据放入协议栈内处理。当再次返回用户空间时会处理协议栈内的数据。

由于响应硬件中断的代价很高，epoll的通知机制并不一定采用中断，可能会采用轮询。

阻塞和非阻塞
是进程相对于内核来说，即读不到足够数据时是继续等待还是返回错误。

epoll为什么边缘触发为什么要非阻塞，水平触发则不必要
边缘触发只会在边缘也就是socket变为可读或可写时触发一次，所以进程需要在一次将数据取完，而进程读取数据时，数据可能没有完全准备好，数据一次没有取完，就再也没有机会取了，除非socket下次变为可读或或写。
设置为非阻塞时，服务端可以调用循环去一直读取数据，直到返回EAGAIN错误，表示没有数据可读。
而设置为阻塞时，服务端必须要知道要读取的

而水平触发不会有这个问题，因为它会在数据没读完时持续返回socket可读，这样，一次读不完数据时就可以再次被触发为可读，从而将数据读完。

而水平触发

小结
---

首先，io复用函数如epoll/select等在等待事件发生的时候都是阻塞的。其次，这里指的非阻塞说的是io复用函数等待的事件，通常是网络连接上的io。最后，为什么使用io复用时，网络io要用非阻塞的？举一个最简单的例子，写的时候，如果协议栈写缓冲区只有1个字节，那么io复用函数会告诉你可写，但如果你此时要写2个字节，如果是阻塞io那么调用write就会阻塞。由于io复用都是单线程调用的，一个连接阻塞就会影响该线程上其他的连接，因此必须使用非阻塞io。ps：上面的答案只有一个是对的。其余的都是胡说八道。建议先搞懂write/read的真实含义以及什么时候会阻塞再来看看你们的答案吧。

https://ws4.sinaimg.cn/large/006tKfTcly1fqc88yrgh2j312g0l8wgc.jpg

其他的答案都没法自洽：都认为只触发一次就必须使用for循环来一次把数据读/写完，如果是阻塞的就会“阻塞”到最后一次循环，可是照这么说水平触发也会阻塞到最后一次被触发。
我觉得这个答案修改一下还可以用：
首先，写过程序的会知道，设置为非阻塞的是 serverSocket，所以考虑时只需要考虑为什么 serverSocket 需要是非阻塞的就好了。

这个答案中，问题在说“ I/O复用都是单线程调用的，一个连接阻塞就会影响该线程上其他的连接，因此必须使用非阻塞io。”，I/O复用是单线程的，可是如果给每个客户端 socket 启用一个新的线程来处理连接，就不会有这个问题了。并不是I/O复用是单线程的，而是 serverSocket 受理连接时同时只能被一个 master 线程处理。

边缘触发之边缘在于"触发条件是缓冲区由不可读/写变为可读/写"
如果 serverSocket 是阻塞的，对于缓冲区满或空时，一次无法完全读写的数据来说，内核会阻塞起来直到对端处理数据后，serverSocket 又可读/写，直到最终成功，但这样会影响其他连接的受理。即socket非常耿直，要一直处理完，不管自己长时间的处理会影响到其他人。
如果 serverSocket 是非阻塞的，如果一次无法完全读写完数据，内核会返回 EAGAIN 错误，这时，可以受理其他连接。等到对端再发送或接收数据，缓冲区由不可读写变为可读写，边缘模式还会再次触发。非阻塞时，socket会理性一些，在自己条件不满足时空出时间给别人执行，等自己条件满足了再触发执行。