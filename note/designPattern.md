设计原则
---
- 抽象；
- 封装变化；
- 多用组合，少用继承；
- 针对接口编程，不针对实现编程；
- 为交互对象之间的松耦合设计而努力；
- 对扩展开放，对修改关闭；
- 依赖抽象，不依赖具体类；
- 最少依赖；
- 由上层类调用底层类，底层类尽量不调用上层父类；
- 一个类只有一个可以改变的方式；

策略模式(Strategy)
---
- 将各种行为抽象成算法； （父类或接口实现会 ：继承造成的大量重写，且父类改变会造成大量子类随之改变，接口实现会有大量的重复实现，且实现时行为不能改变）
- `封装算法为对象`，它们之间可以被相互替换；（给对象提供一个属性存储算法对象，并在实现功能时调用对象的算法）
- 类可以使用算法对象，并可以随时替换；（PHP trait可以达成使用，但无法替换）

观察者模式(Observer)
---
- 一个主题，多个观察者；
- 观察者在主题上注册或注销，而主题只`保存观察者的引用`，不关心观察者的实现；
- 在主题有变化时调用观察者的引用通知已注册的观察者；
- 通知方式有`推`（主题变化时将变化数据推送给观察者）和`拉`（主题只告知变化，观察者主动来拉取数据）

装饰者模式(Decoratro)
---
- 装饰者是一群包装类，由于装饰的复杂性，会多出很多个装饰者小类；
- 装饰者需要被装饰者作为参数传入，并在装饰者内部，在`被装饰者实现的基础上`添加某些功能作为装饰后，提供同被装饰者一样的接口；
- `装饰者与被装饰对象拥有同一个超类`，装饰者拥有被装饰对象的所有外部接口，可被调用，外界无法感知调用的是装饰者还是被装饰者；
- 由于装饰者与被装饰对象拥有同一个超类，所以装饰者也可被另一个装饰者装饰，即重复装饰。
- 装饰者通过封装接口实现功能添加；

工厂模式(Factory)
---
- 工厂模式帮助我们实现依赖倒置，不依赖具体对象，而是通过一个依赖一个对象工厂来依赖抽象。
- 简单工厂模式：接收参数并根据参数创建对应类，将代码与代码实例化的具体类解耦；
- 抽象工厂模式：将工厂的功能`抽象出多个生产接口`，每个工厂会生产同一族的对象，根据使用的工厂不一样，调用生产接口产生的对象也不一样；

单例模式(Singleton)
---
- 对象`全局只能有一个`实例，在第一次实例化后会使用`静态变量保存`实例，后续的调用都使用一个静态方法返回此实例；
- 构造方法私有化，构造方法添加final无法被重写；
- 在多线程时应该考虑`并发`问题，即两次调用都被判定为实例未初始化而重复初始化对象；

命令模式(Command)
---
- 命令模式通过一个`命令对象`来解耦命令发起者与命令执行者；
- 命令对象实现`命令接口（excute 和 undo）`，命令发起者实例化命令对象，并传递此对象，并不关心此对象由谁执行；
- 命令执行者只负责调用命令对象的接口方法即可，不关心对象是由谁生成的；

适配器模式(Adapter)
---
- 适配器模式适用于调用者调用接口与目标接口不一致的情况；
- 适配器通过一个中间对象，`封装目标接口`以`适应调用者`调用；
- 适配器模式是通过封装接口适配调用者与被调用者；

外观模式(Facade)
---
- 外观模式适用于接口众多且组合复杂的情况；
- 外观模式`封装众多复杂`的接口，提供一个`简化接口`内部调用复杂接口来实现；
- 外观模式不会改变原有的多个复杂的单一接口，这些接口依然能被单独调用；
- 外观模式是通过封装接口来将接口简单化；

模板模式(Template)
---
- 模板模式在`抽象类或父类`定义一个`算法的骨架`，统领算法的步骤，而算法的每一个小步骤由不同的子类去具体实现；
- 在模板模式中使用`勾子(hook)`，在子类中判断并进行一些不是所有子类全都需要的步骤；
- 模板模式与策略模式的不同之处在于，策略模式是针对多个不同的算法，而模板模式是针对一个算法的不同步骤，在模板模式中，只有一个算法；

迭代器模式(Iterator)
---
- 迭代器模式允许我们在`不知道内部实现`的情况下`遍历元素`；
- 迭代器模式通过 一个类实现迭代器接口(通常有 `length,next,previous,remove`等方法)，而在外部调用时只关心迭代器接口，不关心其内部实现；

组合模式(Composite)
---
- 组合模式使用一种`组件抽象`来同时表达`集合与元素`，然后使用一个统一的接口来管理集合和元素；
- 组合模式通常设置为`树结构`，在树结构中，父结点和子节点具有同样的抽象和接口；
- 可以给组合模式添加一个迭代器来完成组合结构的迭代；

状态模式(State)
---
- 状态模式抽象出一个事物的`状态作为对象`，替换状态对象作为状态转换的方式；
- 状态对象实现根据状态动作的接口，可以根据不同的`动作做出对应`的反应；
- 状态模式与策略模式的实现相似，但状态模式是对类内部作出改变，而策略模式是针对算法封装；

代理模式(proxy)
---
- 代理模式为一个对象（通常是大对象或无法复制的对象）`创建另外一个类作为其访问的接口`，`所有对真实对象的请求`都通过代理对象完成；
- 代理对象可以`控制用户对真实对象的访问权限`;
- 代理模式的应用场景还有：远程代理（无法直接访问），虚拟代理（大对象，先用虚拟对象作为替代），安全代理（控制访问），指针引用（对真实对象附加功能），延迟加载（请求代理对象确定有效时才创建真实对象）；

复合模式
---
- 复合模式是`多种模式的复合`使用，MVC就是一种复合模式；
- C 是 V的策略，V可以替换不同的C来实现策略模式；
- M 是 V的观察者，在V发生改变时可以通知V进行变动；
- V 可以实现组合模式，在父级有改变时，实现所有子级的共同改变；

桥接模式(bridge)
---
- 桥接模式是为了适应一个事物的多维度变化，将多个维度抽象出来以解耦抽象与实际之间的绑定关系，使抽象和实际向着不同维度改变；
- 解决的问题类似于多继承解决的问题，但是桥接模式通过对象的组合来解决。
- 桥接模式可以轻易在多维度上拓展，而不改变原有模式；
- 桥接模式与策略模式的不同之处：策略模式是针对一个不变的主题替换抽象算法，而桥接模式是策略模式的高维度状态，它的主题也可能会被替换；

建造者模式(builder)
---
- 建造者模式为了降低具有高度相似性的复杂对象的创建代码重复；
- 建造者模式将创建对象部件的一般方法抽象出接口；具体类实现具体的接口；
- 使用导演类依次调用建造者对象的创建部件方法创建对象；
- 建造者模式类似于 命令模式（生成器的构建和传递）+ 外观模式（整合创建方法为一个接口）；
- 作为构造型模式，与工厂模式的区别是，工厂模式会返回一个具体类，而建造者模式会建造出一个由多个类组装而成的完整类；

责任链模式(chain of responsibility)
---
- 责任链模式将任务分层，从最低级向上传递，直到事务被处理；
- 有任务对象和多个处理者对象；
- 每个处理者都会有一个上级；
- 任务开始时选择最低级的处理者试图处理任务；
- 在遇到自己无法处理的情况，传递给上级来处理；

蝇量模式(flyweight)
---
- 使用一个对象来存储和模拟多个虚拟对象，大大减少多个对象的内存占用；
- 蝇量模式可以极大地减少内存占用，也可以方便对多个对象进行统一管理；
- 当一个类有很多实例，而且这些实例能被同一个方法控制的时候；
- 实例一旦实现了蝇量模式，那么单个实例就无法再独立拥有不同的行为；

解释器模式(Intepreter)
---
- 定义一种方法和对应的解释器，使用解释器解释此方法的语句来执行；
- 解释器模式需要上下文类来定义和存储上下文，解释器类用来将语句来翻译成可执行程序；
- 解释器扩展和改变文化非常简单，构建完成后可以很方便地数据格式；
- 解释器模式会将非终结表达式递归解释，直到解释为终结符表达式；
- 解释器模式适用于数据结构不规则，但数据要素相同的情况；语法不能太复杂，复杂的可以使用解释形语言降低复杂性；

中介者模式(mediator)
---
- 通过一个中介对象封装多个对象之间的交互，解耦各个对象之前的相互依赖；
- 对象之间通过中介者进行交互，不必再显示调用目标对象；
- 中介者对对象之间的关系进行了封装，减少了对象之间的耦合，使得对象可以独立改变和复用；
- 中介者模式适合多对多的对象交互情况，中介者适合对象之间交互较多，依赖复杂的情况；

备忘录模式(Memento)
---
- 备忘录模式使用一个备忘录对象记录并保存对象内部状态，并能随时恢复到保存的状态；
- 备忘录对象是一个类似于目标对象的轻量级对象，它保存着目标对象的可变属性；
- 备忘录保管者可以保存多个备忘录，并将对象恢复到任一时刻；
- 备忘录模式适用于需要保存对象历史状态用以支持撤销的场景；

原型模式(Prototype)
---
- 原型模式通过复制`原型对象`再`修改属性`的方式来创建新对象；
- 原型模式使得调用者只知道对象的类型而不必了解创建过程即可创建一个新对象；
- 原型模式可以通过原型对象设置对象的属性，减少类的开放；
- 原型模式适用于对象较大或创建过程较复杂的情况，也适用于需要创建多个有共同“原型”的对象，也即它们拥有大部分共同属性；

访问者模式(Visitor)
---
- 将对一些对象的访问过程抽象出类，以实现在不改变对象的前提下对这些对象添加操作；
- 访问者模式分离对象的数据结构和数据操作；
- 访问者模式将数据的访问方法集中到一个类中，便于对数据访问的统一管理；
- 访问者模式适用于数据结构稳定的类；对对象的同一种数据有多种不同的操作方式；


类之间的关系和UML图：
===
1. 泛化关系(继承关系) generalization ，用 `extends` 实现，C 继承自 P， 由 C 到 P 的一条 `实线带空心箭头` 来表示（子继承父）；
2. 实现关系 Realization：用`implements` 实现， C 实现了 I，由 C 到 I 的一条`虚线带空心箭头`表示（小明实现人）；
3. 聚合关系 aggregation： G 由 E 聚合而成， 则是由 E 向 B 的一条 `实线带空心菱形箭头` 表示， G 和 E 都是可以独立存在的实体（电脑由各个零件聚合而成）；
4. 组合关系 composition： T 由 P1、P2 组合而成，则用 由 P1、P2 向 T 的 `实线带实心菱形箭头`表示，它与聚合关系不同之处在于， P1、P2 依赖于 T，存在，T不存在时，P1、P2 并无实际意义（部门由领导和员工组成）。
5. 关联关系 association： 两个平行的事务对象相关联，有一对一和一对多的关联关系，若 A 与 B 关联，则用 A 和 B 之间的一条 `实线` 表示（员工和领导相关联）；
6. 依赖关系 Dependency：一个对象在运行期间依赖另一个对象，如 A 依赖 B，则用 A 向 B 的`实线带普通箭头`表示（员工用电脑才能工作）；
7.  依赖关系的强弱程度为：`组合>聚合>关联>依赖`